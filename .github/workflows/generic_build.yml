on:
  workflow_call:
    inputs:
      # target image name to build
      image_name:
        required: true
        type: string

      # target tags to build (space-separated)
      tags:
        required: true
        type: string

      # will be passed as a build-arg to Docker
      busybox_version:
        required: false
        type: string

      debian_version:
        required: false
        type: string

      image_prefix:
        required: false
        type: string

      # space-separated list of architectures, e.g., "arm64 amd64"
      archs: 
        required: true
        type: string

      bioconda_utils:
        required: false
        type: boolean

jobs:
  build:
    name: Generic build
    runs-on: ubuntu-22.04

    steps:
    - uses: actions/checkout@v4

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      with:
        platforms: arm64

    - name: Checkout bioconda-utils
      uses: actions/checkout@v4
      if: '${{ inputs.bioconda_utils }}'
      with:
        fetch-depth: 0
        repository: 'bioconda/bioconda-utils'
        path: 'images/bioconda-utils-build-env-cos7/bioconda-utils'

    - name: Build
      id: build
      run: |
        set -xeu

        # Store provided inputs as local vars
        image_name='${{ inputs.image_prefix }}${{ inputs.image_name }}'
        image_dir='images/${{ inputs.image_name }}'
        tags='${{ inputs.tags }}'
        debian_version='${{ inputs.debian_version }}'
        busybox_version='${{ inputs.busybox_version }}'
        archs='${{ inputs.archs }}'
        bioconda_utils='${{ inputs.bioconda_utils }}'

        # Adds image and tags to outputs which can be used in later steps.
        printf %s\\n \
          "image_dir=${image_dir}" \
          "image_name=${image_name}" \
          "tags=$( echo ${tags} )" \
          >> $GITHUB_OUTPUT

        # Dockerfile lives here
        cd $image_dir

        for tag in ${tags} ; do
          buildah manifest create "${image_name}:${tag}"
        done

        # get space-separated archs input string into an array
        read -r -a archs_and_images <<<"$archs"

        # ----------------------------------------------------------------------
        # Incrementally compose build args, depending on which inputs were
        # provided.
        BUILD_ARGS=()
        if [ ! -z "${debian_version}" ]; then
          BUILD_ARGS+=("--build-arg=debian_version=$debian_version")
        fi

        if [ "${bioconda_utils}" == "true" ]; then
        # Due to different nomenclature used by conda-forge and buildah, we
        # need to map archs to base images.
          archs_and_images=(
            "amd64=quay.io/condaforge/linux-anvil-cos7-x86_64"
            "arm64=quay.io/condaforge/linux-anvil-aarch64"
          )
        fi

        # If busybox_version was specified, assume we are making a busybox image.
        if [ ! -z "${busybox_version}" ]; then
          BUILD_ARGS+=("--build-arg=busybox_version=$busybox_version")

          # Make a busybox image that we'll use further below. As shown in the
          # Dockerfile.busybox, this uses the build-busybox script which in turn
          # cross-compiles for x86_64 and aarch64, and these are later copied
          # into an arch-specific container.
          # --iidfile prints the built image ID to the specified file so we can
          # refer to the image later
          iidfile="$( mktemp )"
          buildah bud \
            --iidfile="${iidfile}" \
            --file=Dockerfile.busybox \
            ${BUILD_ARGS[@]}
          busybox_image="$( cat "${iidfile}" )"
          rm "${iidfile}"

          # And then extend the build args with this image.
          BUILD_ARGS+=("--build-arg=busybox_image=${busybox_image}")
        fi

        # ----------------------------------------------------------------------

        # Build each arch's image
        for arch_and_image in "${archs_and_images[@]}" ; do
          arch=$(echo $arch_and_image | cut -f1 -d "=")
          base_image=$(echo $arch_and_image | cut -f2 -d "=")
          BASE_IMAGE_BUILD_ARG=""
          if [ ! -z "$base_image" ]; then
            BASE_IMAGE_BUILD_ARG="--build-arg=base_image="${base_image}""
          fi

          iidfile="$( mktemp )"
          buildah bud \
            --arch="${arch}" \
            --iidfile="${iidfile}" \
            ${BUILD_ARGS[@]} \
            $BASE_IMAGE_BUILD_ARG
          image_id="$( cat "${iidfile}" )"
          rm "${iidfile}"

          # Extract various package info and version info, then store that info
          # as labels. Container is removed at the end to avoid e.g. having these
          # commands in the history of the container.
          container="$( buildah from "${image_id}" )"
          run() { buildah run "${container}" "${@}" ; }
          LABELS=()
          LABELS+=("--label=deb-list=\"$( run cat /.deb.lst | tr '\n' '|' | sed 's/|$//' )\"")
          LABELS+=("--label=pkg-list=\"$( run cat /.pkg.lst | tr '\n' '|' | sed 's/|$//' )\"")
          LABELS+=("--label=glibc=\"$( run sh -c 'exec "$( find -xdev -name libc.so.6 -print -quit )"' | sed '1!d' )\"")
          LABELS+=("--label=debian=\"$( run cat /etc/debian_version | sed '1!d' )\"")
          LABELS+=("--label=bash=\"$( run bash --version | sed '1!d' )\"")

          if [ "${bioconda_utils}" == "true" ]; then
            bioconda_utils="$(
              run sh -c '. /opt/conda/etc/profile.d/conda.sh && conda activate base && bioconda-utils --version' \
              | rev | cut -f1 -d " " | rev 
            )"
            LABELS+=("--label=bioconda-utils=\"${bioconda_utils}\"")
          fi

          if [ ! -z "${busybox_version}" ]; then
            LABELS+=("--label=busybox-version=\"${busybox_version}\"")
          fi
          buildah rm "${container}"

          # Add labels to a new container...
          container="$( buildah from "${image_id}" )"

          # FIXME: Test out different options
          declare -a mycmd=( buildah config ${LABELS[@]} "${container}" )
          echo "Label args: " "${LABELS[@]}"
          echo "Label args with @Q: " "${LABELS[@]@Q}"
          echo "Label command: " "${mycmd[@]}"
          echo "Label command with @Q: " "${mycmd[@]@Q}"

          buildah config "${LABELS[@]}" "${container}"

          # ...then store the container (now with labels) as a new image. This
          # is what we'll use to upload.
          image_id="$( buildah commit "${container}" )"
          buildah rm "${container}"

          # Add images to manifest. Individual image tags include arch; manifest does not.
          for tag in ${tags} ; do
            buildah tag \
              "${image_id}" \
              "${image_name}:${tag}-${arch}"
            buildah manifest add \
              "${image_name}:${tag}" \
              "${image_id}"

            buildah inspect -t image ${image_name}:${tag}-${arch}
          done
        done
        buildah inspect -t manifest ${image_name}

    - name: Test
      run: |
        set -xeu

        # Store inputs as local variables
        image_name='${{ inputs.image_name }}'
        image_dir="images/${image_name}"

        # Extract image IDs from the manifest built in the last step
        ids="$(
          for tag in ${{ inputs.tags }} ; do
            buildah manifest inspect "${image_name}:${tag}" \
              | jq -r '.manifests[]|.digest' \
              | while read id ; do
                  buildah images --format '{{.ID}}{{.Digest}}' \
                  | sed -n "s/${id}//p"
                done
          done
          )"

        # Run the tests; see Dockerfile.test in the relevant image dir for the
        # actual tests run
        ids="$( printf %s "${ids}" | sort -u )"
        for id in ${ids} ; do
          podman history "${id}"
          buildah bud \
            --build-arg=base="${id}" \
            --file=Dockerfile.test \
            "${image_dir}"
        done
        buildah rmi --prune || true
